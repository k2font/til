# 幅優先探索(BFS)

### 概要
グラフの探索を行うアルゴリズム。ノードを網羅的に探索するタイプ。

始点から近い順に探索を行うため、探索するノードはキュー(FIFO)を使って管理する。

1. 始点のノードを探索待ちキューに追加する。
2. 探索待ちキューにノードがあれば取り出す。無ければ全ノード探索完了。
3. 取り出したノードが目的ノードであれば探索完了。
4. 取り出したノードに隣接するノードの内、未探索のノードを探索待ちキューに追加する。
5. 2に戻る。

これを行うことで、始点から近い順に探索ができる。

主に、最短経路の特定に利用することができる。DFSに比べ計算量が少ない。
(というより、DFSはグラフにおける最短経路の特定に適さない、というのが正しい)

### サンプルコード

#### 入力形式
```
N M
a_0 b_0
a_1 b_1
.
.
a_M−1 b_M−1
```

#### 入力例
```
9 13
0 1
0 4
0 2
1 4
1 3
1 8
2 5
3 8
4 8
5 8
5 6
3 7
6 7
```

```cpp
#include <bits/stdc++.h>
using namespace std;
using Graph = vector<vector<int>>; // グラフの型を作成する
// 隣接リストを用いる

int main() {
    // 頂点数と辺数
    int N, M; cin >> N >> M;

    // グラフ入力受取 (ここでは無向グラフを想定)
    Graph G(N); // わかりにくく見えるが、vector<vector<int>> G(N)と同値
    for (int i = 0; i < M; ++i) {
        int a, b; cin >> a >> b;
				G[a].push_back(b); // 無向グラフのデータを突っ込もうとしている。
        G[b].push_back(a); // つまり、aとbがつながっているという意味。それをGに入れて管理している
				// 上記の処理の結果、以下のようになる
				// a<->b, ex)6<->4
				// b<->a, ex)4<->6
    }

    // BFS のためのデータ構造
    vector<int> dist(N, -1); // 全頂点を「未訪問」に初期化
    queue<int> que;

    // 初期条件 (頂点 0 を初期ノードとする)
    dist[0] = 0;
    que.push(0); // 0 を橙色頂点にする

    // BFS 開始 (キューが空になるまで探索を行う)
    while (!que.empty()) {
        int v = que.front(); // キューから先頭頂点を取り出す
        que.pop();

        // v から辿れる頂点をすべて調べる
        for (int nv : G[v]) {
            if (dist[nv] != -1) continue; // すでに発見済みの頂点は探索しない

            // 新たな白色頂点 nv について距離情報を更新してキューに追加する
            dist[nv] = dist[v] + 1;
            que.push(nv);
        }
    }

    // 結果出力 (各頂点の頂点 0 からの距離を見る)
    for (int v = 0; v < N; ++v) cout << v << ": " << dist[v] << endl;
}
```

参考

[https://qiita.com/drken/items/996d80bcae64649a6580](https://qiita.com/drken/items/996d80bcae64649a6580)